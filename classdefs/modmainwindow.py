from PySide6.QtWidgets import QMainWindow
from PySide6.QtGui import QAction
import numpy as np

from qtdesigner.mainui.UI_nemo_main_window import Ui_NemoMainWindow
from qtdesigner.dialogs.moddialogimportnmoperiodicampsmat import DialogImportNMOPeriodicMat
from functions.modgeneratetimevectorus import generate_time_vector_us
from functions.modloadnmoperiodicampsfrommatfile import load_nmo_periodic_amps_from_mat_file
from functions.modextracttkcontributions import extract_tk_contributions
from functions.modcomputethyp import compute_t_hyp_us
from classdefs.modboundaryline import BoundaryLine


class NemoMainWindow(QMainWindow, Ui_NemoMainWindow):
    def __init__(self):
        super().__init__()
        # Call the 'setupUi' method built into UiMainWindow, auto-generated by Qt Designer:
        self.setupUi(self)

        # Instance variables:
        self.b_scan_amplitudes_raw = None
        self.b_scan_amps_modified = None
        self.t_min_us_scope = None
        self.t_max_us_scope = None
        self.pitch_mm = None
        self.x_vector_mm = None
        self.t_vector_us = None
        self.v_vector_mpers = None
        self.t_0_vector_us = None
        self.spectrum_contributions_3d = None
        self.query_times_by_a_scan_3d = None
        self.n_samples = None
        self.n_a_scans = None
        self.x_max_mm = None
        self.boundary_line_x_min = None
        self.boundary_i_min = 0
        self.boundary_line_x_max = None
        self.boundary_i_max = None

        # Set window title:
        self.setWindowTitle('Nemo')

        # Create menus:
        self.menu_file = self.menubar.addMenu('File')

        # Create sub-menus:
        self.menu_open = self.menu_file.addMenu('Open')

        # Create actions:
        # Action to open a .mat file:
        action_open_nmo_periodic_mat = QAction('.mat off-end periodic 2D array format', parent=self)
        action_open_nmo_periodic_mat.setStatusTip(
            'Import the amplitude data from an NMO B-scan from a .mat file (2D A-scan array format).')
        action_open_nmo_periodic_mat.triggered.connect(self.open_nmo_periodic_mat)

        # Add actions to menus:
        self.menu_open.addAction(action_open_nmo_periodic_mat)

        # Wire signals to slots:
        # Qt signals:
        self.doubleSpinBox_nmo_c_min.valueChanged.connect(self.nmo_c_min_changed)
        self.doubleSpinBox_nmo_c_max.valueChanged.connect(self.nmo_c_max_changed)
        self.doubleSpinBox_tk_c_min.valueChanged.connect(self.tk_c_min_changed)
        self.doubleSpinBox_tk_c_max.valueChanged.connect(self.tk_c_max_changed)
        self.doubleSpinBox_nmo_t_min.valueChanged.connect(self.nmo_t_min_changed)
        self.doubleSpinBox_nmo_t_max.valueChanged.connect(self.nmo_t_max_changed)
        self.doubleSpinBox_tk_v_min.editingFinished.connect(self.v_vector_changed)
        self.doubleSpinBox_tk_v_max.editingFinished.connect(self.v_vector_changed)
        self.doubleSpinBox_tk_t_0_min.editingFinished.connect(self.t_0_vector_changed)
        self.doubleSpinBox_tk_t_0_max.editingFinished.connect(self.t_0_vector_changed)
        self.spinBox_tk_n_vs.editingFinished.connect(self.v_vector_changed)
        self.spinBox_tk_n_t0s.editingFinished.connect(self.t_0_vector_changed)
        self.doubleSpinBox_rise_time_us.editingFinished.connect(self.rise_time_changed)
        self.checkBox_x_max.checkStateChanged.connect(self.checkbox_x_max_toggled)
        # Matplotlib signals:
        self.tk_spectrum_widget.mpl_canvas.fig.canvas.mpl_connect('motion_notify_event', self.tk_hover)

    def open_nmo_periodic_mat(self):
        # Ask the user for the file import and display parameters:
        provided, name, file_path, self.t_min_us_scope, self.t_max_us_scope, self.pitch_mm = self.request_file_import_params()

        # Proceed differently based on the value of 'provided':
        if provided:
            # The user has provided file import parameters and wishes to continue with the data import:
            # Import the amplitude data array:
            self.b_scan_amplitudes_raw = load_nmo_periodic_amps_from_mat_file(file_path)

            # Generate the time vector using the scope time limits provided:
            self.n_samples, self.n_a_scans = np.shape(self.b_scan_amplitudes_raw)
            self.t_vector_us = generate_time_vector_us(self.t_min_us_scope, self.t_max_us_scope, self.n_samples)
            # Generate x vector:
            self.x_max_mm = (self.n_a_scans - 1) * self.pitch_mm
            self.x_vector_mm = np.linspace(0, self.x_max_mm, self.n_a_scans)
            # Set x boundaries to contain all data:
            self.boundary_i_max = self.n_a_scans

            # Update everything to reflect the new fmclp data set:
            # No modifiers applied yet:
            self.b_scan_amps_modified = self.b_scan_amplitudes_raw
            # Display the NMO B-scan:
            self.nmo_b_scan_widget.new_amplitude_array(self.b_scan_amps_modified)
            # Set c lims for NMO B-scan plot:
            self.nmo_b_scan_widget.axes_image.set_clim(vmin=-10 / 1000, vmax=10 / 1000)
            self.doubleSpinBox_nmo_c_min.setValue(-10)
            self.doubleSpinBox_nmo_c_max.setValue(10)
            # Set extent:
            self.nmo_b_scan_widget.axes_image.set_extent((0,
                                                          self.x_max_mm,
                                                          self.t_max_us_scope,
                                                          self.t_min_us_scope))
            # Set axis limits:
            self.nmo_b_scan_widget.mpl_canvas.ax.set_xlim(0, self.x_max_mm)
            self.nmo_b_scan_widget.mpl_canvas.ax.set_ylim(self.t_max_us_scope, self.t_min_us_scope)
            self.nmo_b_scan_widget.mpl_canvas.draw()

            # Set x data for interactive lines:
            self.nmo_b_scan_widget.hyperbola_hover.set_xdata(self.x_vector_mm)
            #self.nmo_b_scan_widget.hyperbola_click.set_xdata(self.x_vector_mm)

            # Update plot variable input widgets based on dataset limits:
            # NMO plot variables:
            self.doubleSpinBox_nmo_t_min.blockSignals(True)
            self.doubleSpinBox_nmo_t_min.setValue(self.t_min_us_scope)
            self.doubleSpinBox_nmo_t_min.blockSignals(False)
            self.doubleSpinBox_nmo_t_max.blockSignals(True)
            self.doubleSpinBox_nmo_t_max.setValue(self.t_max_us_scope)
            self.doubleSpinBox_nmo_t_max.blockSignals(False)
            self.doubleSpinBox_nmo_t_min.setMinimum(self.t_min_us_scope)
            self.doubleSpinBox_nmo_t_max.setMaximum(self.t_max_us_scope)
            # TK spectrum variables:
            self.doubleSpinBox_tk_t_0_max.blockSignals(True)
            self.doubleSpinBox_tk_t_0_max.setValue(self.t_max_us_scope / 2)
            self.doubleSpinBox_tk_t_0_max.blockSignals(False)
            self.doubleSpinBox_tk_t_0_min.setMinimum(self.t_min_us_scope)
            self.doubleSpinBox_tk_t_0_max.setMaximum(self.t_max_us_scope)

            # Generate v and t_0 vectors:
            self.generate_v_vector_from_limits()
            self.generate_t_0_vector_from_limits()
            # Set v data for the iso-b line & text:
            self.tk_spectrum_widget.line_iso_b.set_xdata(self.v_vector_mpers)
            self.tk_spectrum_widget.text_iso_b.set_x(self.doubleSpinBox_tk_v_max.value())

            # Compute a default TK spectrum using the imported data:
            tk_spectrum_amps = self.compute_tk_from_vectors()

            # Display T-K spectrum:
            # Set data:
            self.tk_spectrum_widget.axes_image.set_data(tk_spectrum_amps)
            # Set Clims for T-K spectrum:
            self.set_tk_clims_from_box_values()
            # Set TK spectrum image extent:
            self.set_tk_extent_from_box_values()

            # Set v data for the iso-b line & text:
            self.tk_spectrum_widget.line_iso_b.set_xdata(self.v_vector_mpers)
            self.tk_spectrum_widget.text_iso_b.set_x(self.doubleSpinBox_tk_v_max.value())

            # Draw T-K plot canvas:
            self.tk_spectrum_widget.mpl_canvas.draw()

            # Enable interactive widgets associated with the b-scan plot and Taner-Koehler spectrum:
            self.activate_plot_input_widgets()

            # Enable add modifier button:
            self.pushButton_add_modifier.setEnabled(True)

            # Display the data set name in the label at the top of the screen:
            if name:
                self.label_data_set_name.setText(name)

    def request_file_import_params(self):
        # Open a dialog to request the file import parameters:
        dialog_file_import_params = DialogImportNMOPeriodicMat(parent=self)
        dialog_file_import_params.exec()
        # When the dialog has either been accepted or rejected:
        # Boolean showing whether the user clicked 'accept' or 'cancel':
        provided = dialog_file_import_params.result()
        # Other parameters:
        name = dialog_file_import_params.name_string
        file_path = dialog_file_import_params.file_path
        t_min_us = dialog_file_import_params.t_min_us
        t_max_us = dialog_file_import_params.t_max_us
        pitch_mm = dialog_file_import_params.pitch_mm

        return provided, name, file_path, t_min_us, t_max_us, pitch_mm

    def generate_t_0_vector_from_limits(self):
        self.t_0_vector_us = np.linspace(start=self.doubleSpinBox_tk_t_0_min.value(),
                                         stop=self.doubleSpinBox_tk_t_0_max.value(),
                                         num=self.spinBox_tk_n_t0s.value())

    def generate_v_vector_from_limits(self):
        self.v_vector_mpers = np.linspace(start=self.doubleSpinBox_tk_v_min.value(),
                                          stop=self.doubleSpinBox_tk_v_max.value(),
                                          num=self.spinBox_tk_n_vs.value())

    def set_tk_clims_from_box_values(self):
        self.tk_spectrum_widget.axes_image.set_clim(vmin=self.doubleSpinBox_tk_c_min.value(),
                                                    vmax=self.doubleSpinBox_tk_c_max.value())

    def set_tk_extent_from_box_values(self):
        self.tk_spectrum_widget.axes_image.set_extent((self.doubleSpinBox_tk_v_min.value(),
                                                       self.doubleSpinBox_tk_v_max.value(),
                                                       self.doubleSpinBox_tk_t_0_max.value(),
                                                       self.doubleSpinBox_tk_t_0_min.value()))

    def new_tk_spectrum_amps_array(self, tk_amps_array):
        # Display the new array of TK spectrum amplitudes:
        # Set data:
        self.tk_spectrum_widget.axes_image.set_data(tk_amps_array)
        # Set extent:
        self.set_tk_extent_from_box_values()
        # Set v data for the iso-b line & text:
        self.tk_spectrum_widget.line_iso_b.set_xdata(self.v_vector_mpers)
        self.tk_spectrum_widget.text_iso_b.set_x(self.doubleSpinBox_tk_v_max.value())
        # Clear t_0 data for iso-b line:
        self.tk_spectrum_widget.line_iso_b.set_ydata([])
        # Make iso-b line and text invisible:
        self.tk_spectrum_widget.line_iso_b.set_visible(False)
        self.tk_spectrum_widget.text_iso_b.set_visible(False)
        # Make mouse hover hyperbola invisible:
        self.nmo_b_scan_widget.hyperbola_hover.set_visible(False)

    def compute_tk_from_vectors(self):
        # Extract the contributions to the TK spectrum from each A-scan by interpolating the B-scan:
        self.extract_tk_contributions()
        # Apply any masks requested by tools:
        self.mask_tk_contributions()
        # Sum the contributions over the range of A-scans requested by tools:
        tk_spectrum_amps = self.sum_tk_contributions()
        return tk_spectrum_amps

    def extract_tk_contributions(self):
        self.spectrum_contributions_3d, self.query_times_by_a_scan_3d = extract_tk_contributions(
            self.b_scan_amps_modified, self.t_vector_us, self.x_vector_mm, self.v_vector_mpers, self.t_0_vector_us)

    def mask_tk_contributions(self):
        if self.groupBox_box_mask.isChecked():
            # The user has requested to exclude a particular region of the B-scan from contributing to the TK spectrum.
            # Create masks based on the values of the query times for the excluded A-scans:
            # Copy masks from query times array to spectrum contributions array:
            pass
        else:
            # No masking requested.
            pass

    def sum_tk_contributions(self):
        # Sum contributions according to x_min and x_max boundaries:
        tk_spectrum_amps = np.sum(self.spectrum_contributions_3d[self.boundary_i_min : self.boundary_i_max], axis=0)
        return tk_spectrum_amps

    def nmo_c_min_changed(self, c_min_mv):
        self.nmo_b_scan_widget.axes_image.set_clim(vmin=c_min_mv / 1000)
        self.nmo_b_scan_widget.mpl_canvas.draw()

    def nmo_c_max_changed(self, c_max_mv):
        self.nmo_b_scan_widget.axes_image.set_clim(vmax=c_max_mv / 1000)
        self.nmo_b_scan_widget.mpl_canvas.draw()

    def tk_c_min_changed(self, c_min):
        self.tk_spectrum_widget.axes_image.set_clim(vmin=c_min)
        self.tk_spectrum_widget.mpl_canvas.draw()

    def tk_c_max_changed(self, c_max):
        self.tk_spectrum_widget.axes_image.set_clim(vmax=c_max)
        self.tk_spectrum_widget.mpl_canvas.draw()

    def nmo_t_min_changed(self, t_min_us):
        self.nmo_b_scan_widget.mpl_canvas.ax.set_ylim(top=t_min_us)
        self.nmo_b_scan_widget.mpl_canvas.draw()

    def nmo_t_max_changed(self, t_max_us):
        self.nmo_b_scan_widget.mpl_canvas.ax.set_ylim(bottom=t_max_us)
        self.nmo_b_scan_widget.mpl_canvas.draw()

    def tk_hover(self, event):
        if self.b_scan_amplitudes_raw is None:
            # No dataset loaded.  Take no action.
            return
        elif not event.inaxes:
            # Mouse is in TK figure but not in data axes.
            # Check if hyperbola is visible:
            hyp_hover_visible = self.nmo_b_scan_widget.hyperbola_hover.get_visible()
            if hyp_hover_visible:
                # Make invisible:
                self.nmo_b_scan_widget.hyperbola_hover.set_visible(False)
                self.tk_spectrum_widget.line_iso_b.set_visible(False)
                self.tk_spectrum_widget.text_iso_b.set_visible(False)
                # Blit to remove:
                self.nmo_b_scan_widget.blit_manager.blit_all_animated_artists()
                self.tk_spectrum_widget.blit_manager.blit_all_animated_artists()
            else:
                # Hyperbola is already invisible.  No need to blit.
                pass
        else:
            # Mouse is in TK data axes.
            v_hover_mpers = event.xdata
            t_0_hover_us = event.ydata
            # Draw hyperbola for hovered [v,b] point:
            # Compute t values for this hyperbola:
            t_hyp_us = compute_t_hyp_us(self.x_vector_mm, v_hover_mpers, t_0_hover_us)
            # Set ydata for hyp line:
            self.nmo_b_scan_widget.hyperbola_hover.set_ydata(t_hyp_us)
            # Check if hyp hover is visible:
            if not self.nmo_b_scan_widget.hyperbola_hover.get_visible():
                # Hyp hover is invisible.
                # Make visible:
                self.nmo_b_scan_widget.hyperbola_hover.set_visible(True)
                self.tk_spectrum_widget.line_iso_b.set_visible(True)
                self.tk_spectrum_widget.text_iso_b.set_visible(True)

            # Draw iso-b line on TK spectrum:
            # Compute b:
            b_hover_mm = 10**3 * 0.5 * t_0_hover_us * 10**-6 * v_hover_mpers
            # Compute t_0 values for this b value:
            t_0s_iso_b_line_us = 10**6 * 2 * b_hover_mm * 10**-3 / self.v_vector_mpers
            # Set ydata for iso-b line:
            self.tk_spectrum_widget.line_iso_b.set_ydata(t_0s_iso_b_line_us)

            # Update text label:
            self.tk_spectrum_widget.text_iso_b.set_text(f'b={b_hover_mm:.2f}mm')
            # Update text location:
            self.tk_spectrum_widget.text_iso_b.set_y(t_0s_iso_b_line_us[-1])

            # Blit changes:
            self.nmo_b_scan_widget.blit_manager.blit_all_animated_artists()
            self.tk_spectrum_widget.blit_manager.blit_all_animated_artists()

    def activate_plot_input_widgets(self):
        # NMO B-scan plot widgets:
        # Plot tab:
        self.doubleSpinBox_nmo_c_min.setEnabled(True)
        self.doubleSpinBox_nmo_c_max.setEnabled(True)
        self.doubleSpinBox_nmo_t_min.setEnabled(True)
        self.doubleSpinBox_nmo_t_max.setEnabled(True)
        # Data tab:
        self.doubleSpinBox_source_half_width_mm.setEnabled(True)
        self.doubleSpinBox_rise_time_us.setEnabled(True)
        # Tools tab:
        self.checkBox_x_max.setEnabled(True)
        self.groupBox_box_mask.setEnabled(True)
        self.doubleSpinBox_box_mask_t_lower.setEnabled(True)
        self.doubleSpinBox_box_mask_t_upper.setEnabled(True)
        self.spinBox_box_mask_i_lower.setEnabled(True)
        self.spinBox_box_mask_i_upper.setEnabled(True)
        # T-K spectrum plot widgets:
        # Plot tab:
        self.doubleSpinBox_tk_c_min.setEnabled(True)
        self.doubleSpinBox_tk_c_max.setEnabled(True)
        # Data tab:
        self.doubleSpinBox_tk_v_min.setEnabled(True)
        self.doubleSpinBox_tk_v_max.setEnabled(True)
        self.doubleSpinBox_tk_t_0_min.setEnabled(True)
        self.doubleSpinBox_tk_t_0_max.setEnabled(True)
        self.spinBox_tk_n_vs.setEnabled(True)
        self.spinBox_tk_n_t0s.setEnabled(True)

    def v_vector_changed(self):
        # Compute new v vector:
        self.generate_v_vector_from_limits()
        # Set v data for the iso-b line & text:
        self.tk_spectrum_widget.line_iso_b.set_xdata(self.v_vector_mpers)
        self.tk_spectrum_widget.text_iso_b.set_x(self.doubleSpinBox_tk_v_max.value())
        # Compute new T-K spectrum amplitudes:
        tk_spectrum_amps = self.compute_tk_from_vectors()
        # Display new spectrum array:
        self.new_tk_spectrum_amps_array(tk_spectrum_amps)
        # Draw T-K plot canvas:
        self.tk_spectrum_widget.mpl_canvas.draw()
        # Blit NMO canvas (to remove hyperbola):
        self.nmo_b_scan_widget.blit_manager.blit_all_animated_artists()

    def t_0_vector_changed(self):
        # Compute new t_0 vector:
        self.generate_t_0_vector_from_limits()
        # Compute new T-K spectrum amplitudes:
        tk_spectrum_amps = self.compute_tk_from_vectors()
        # Display new spectrum array:
        self.new_tk_spectrum_amps_array(tk_spectrum_amps)
        # Draw T-K plot canvas:
        self.tk_spectrum_widget.mpl_canvas.draw()
        # Blit NMO canvas (to remove hyperbola):
        self.nmo_b_scan_widget.blit_manager.blit_all_animated_artists()

    def rise_time_changed(self):
        rise_time_us = self.doubleSpinBox_rise_time_us.value()
        # Compute new time min and max:
        t_min_rise_time_us = self.t_min_us_scope - rise_time_us
        t_max_rise_time_us = self.t_max_us_scope - rise_time_us
        # Re-compute time vector:
        self.t_vector_us = generate_time_vector_us(t_min_rise_time_us, t_max_rise_time_us, self.n_samples)

        # Update plot variable input widgets based on dataset limits:
        # NMO plot variables:
        self.doubleSpinBox_nmo_t_min.blockSignals(True)
        self.doubleSpinBox_nmo_t_min.setValue(t_min_rise_time_us)
        self.doubleSpinBox_nmo_t_min.blockSignals(False)
        self.doubleSpinBox_nmo_t_max.blockSignals(True)
        self.doubleSpinBox_nmo_t_max.setValue(t_max_rise_time_us)
        self.doubleSpinBox_nmo_t_max.blockSignals(False)
        self.doubleSpinBox_nmo_t_min.setMinimum(t_min_rise_time_us)
        self.doubleSpinBox_nmo_t_max.setMaximum(t_max_rise_time_us)
        # TK spectrum variables:
        self.doubleSpinBox_tk_t_0_min.setMinimum(t_min_rise_time_us)
        self.doubleSpinBox_tk_t_0_max.setMaximum(t_max_rise_time_us)

        # Update the NMO B-scan extent:
        self.nmo_b_scan_widget.axes_image.set_extent((0, self.x_max_mm, t_max_rise_time_us, t_min_rise_time_us))

        # Update the T-K spectrum data:
        tk_spectrum_amps = self.compute_tk_from_vectors()
        self.new_tk_spectrum_amps_array(tk_spectrum_amps)

        # Draw both axes:
        self.tk_spectrum_widget.mpl_canvas.draw()
        self.nmo_b_scan_widget.mpl_canvas.draw()

    def checkbox_x_max_toggled(self):
        if self.checkBox_x_max.isChecked():
            # The user has checked the checkbox, requesting an x max boundary line:
            self.boundary_line_x_max = BoundaryLine(self.nmo_b_scan_widget.mpl_canvas,
                                                    'x', 'max',
                                                    self.nmo_b_scan_widget.blit_manager,
                                                    self.nmo_b_scan_widget.cursor_manager)
            # Wire the boundary_moved signal to the boundary_x_max changed method:
            self.boundary_line_x_max.boundary_moved.connect(self.boundary_x_max_changed)
        else:
            # The user is requesting to remove the existing x_max boundary line:
            self.boundary_line_x_max.safe_disconnect()
            self.boundary_line_x_max = None
            # Re-set the TK spectrum using the whole B-scan:
            self.boundary_x_max_changed(self.x_max_mm)
            
        # Blit appearance or disappearance:
        self.nmo_b_scan_widget.blit_manager.blit_all_animated_artists()

    def boundary_x_max_changed(self, boundary_x_max_mm):
        self.boundary_i_max = round(boundary_x_max_mm / self.pitch_mm)
        # Sum TK contributions within new boundaries:
        tk_spectrum_amps = self.sum_tk_contributions()
        # Set data for new TK spectrum:
        self.tk_spectrum_widget.axes_image.set_data(tk_spectrum_amps)
        # Re-draw the TK spectrum plot:
        self.tk_spectrum_widget.mpl_canvas.draw()
