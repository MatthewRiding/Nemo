from PySide6.QtWidgets import QMainWindow
from PySide6.QtGui import QAction
import numpy as np
from matplotlib.widgets import RectangleSelector

from qtdesigner.mainui.UI_nemo_main_window import Ui_NemoMainWindow
from qtdesigner.dialogs.moddialogimportnmoperiodicampsmat import DialogImportNMOPeriodicMat
from functions.modgeneratetimevectorus import generate_time_vector_us
from functions.modloadnmoperiodicampsfrommatfile import load_nmo_periodic_amps_from_mat_file
from functions.modextracttkcontributions import extract_tk_contributions
from functions.modcomputethyp import compute_t_hyp_us
from classdefs.modboundaryline import BoundaryLine
from classdefs.modtkzoomwidget import TKZoomWidget
from classdefs.modpcvviewer import PCVViewer
from qtdesigner.dialogs.PrettyPrint.moddialogprettyprint import DialogPrettyPrint


class NemoMainWindow(QMainWindow, Ui_NemoMainWindow):
    def __init__(self):
        super().__init__()
        # Call the 'setupUi' method built into UiMainWindow, auto-generated by Qt Designer:
        self.setupUi(self)

        # Instance variables:
        self.b_scan_amplitudes_raw_nm = None
        self.b_scan_amps_modified_nm = None
        self.t_min_us_scope = None
        self.t_max_us_scope = None
        self.pitch_mm = None
        self.x_vector_mm = None
        self.t_vector_us = None
        self.v_vector_mpers = None
        self.t_0_vector_us = None
        self.spectrum_contributions_3d = None
        self.query_times_by_a_scan_3d = None
        self.n_samples = None
        self.n_a_scans = 2
        self.x_max_mm = None
        self.boundary_line_x_min = None
        self.boundary_i_min = 0
        self.boundary_line_x_max = None
        self.boundary_i_max = None
        self.rect_selector_tk = None
        self.tk_zoom_widget = None
        self.pcv_viewer_widget = None
        self.tuple_v_t_0_clicked = None

        # Set window title:
        self.setWindowTitle('Nemo')

        # Create menus:
        self.menu_file = self.menubar.addMenu('File')
        self.menu_windows = self.menubar.addMenu('Windows')

        # Create sub-menus:
        self.menu_open = self.menu_file.addMenu('Open')

        # Create actions:
        # Action to open a .mat file:
        action_open_nmo_periodic_mat = QAction('.mat off-end periodic 2D array format', parent=self)
        action_open_nmo_periodic_mat.setStatusTip(
            'Import the amplitude data from an NMO B-scan from a .mat file (2D A-scan array format).')
        action_open_nmo_periodic_mat.triggered.connect(self.open_nmo_periodic_mat)
        # Action to toggle the pixel contributions vector viewer window:
        self.action_toggle_pcv_viewer = QAction('PCV viewer', parent=self)
        self.action_toggle_pcv_viewer.setCheckable(True)
        self.action_toggle_pcv_viewer.triggered.connect(self.toggle_pcv_viewer)

        # Add actions to menus:
        self.menu_open.addAction(action_open_nmo_periodic_mat)
        self.menu_windows.addAction(self.action_toggle_pcv_viewer)

        # Wire signals to slots:
        # Qt signals:
        self.doubleSpinBox_nmo_c_min.valueChanged.connect(self.nmo_c_min_changed)
        self.doubleSpinBox_nmo_c_max.valueChanged.connect(self.nmo_c_max_changed)
        self.doubleSpinBox_tk_c_min.valueChanged.connect(self.tk_c_min_changed)
        self.doubleSpinBox_tk_c_max.valueChanged.connect(self.tk_c_max_changed)
        self.doubleSpinBox_nmo_t_min.valueChanged.connect(self.nmo_t_min_changed)
        self.doubleSpinBox_nmo_t_max.valueChanged.connect(self.nmo_t_max_changed)
        self.doubleSpinBox_tk_v_min.editingFinished.connect(self.v_vector_changed)
        self.doubleSpinBox_tk_v_max.editingFinished.connect(self.v_vector_changed)
        self.doubleSpinBox_tk_t_0_min.editingFinished.connect(self.t_0_vector_changed)
        self.doubleSpinBox_tk_t_0_max.editingFinished.connect(self.t_0_vector_changed)
        self.spinBox_tk_n_vs.editingFinished.connect(self.v_vector_changed)
        self.spinBox_tk_n_t0s.editingFinished.connect(self.t_0_vector_changed)
        self.doubleSpinBox_rise_time_us.editingFinished.connect(self.rise_time_changed)
        self.checkBox_x_max.checkStateChanged.connect(self.checkbox_x_max_toggled)
        self.pushButton_box_select.clicked.connect(self.tk_box_select_button_clicked)
        self.pushButton_print_tk.clicked.connect(self.print_tk_clicked)
        self.tk_spectrum_widget.pixel_clicked.connect(self.tk_pixel_clicked)
        # Matplotlib signals:
        self.tk_spectrum_widget.mpl_canvas.fig.canvas.mpl_connect('motion_notify_event', self.tk_hover)

    def open_nmo_periodic_mat(self):
        # Ask the user for the file import and display parameters:
        provided, name, file_path, self.t_min_us_scope, self.t_max_us_scope, self.pitch_mm = self.request_file_import_params()

        # Proceed differently based on the value of 'provided':
        if provided:
            # The user has provided file import parameters and wishes to continue with the data import:
            # Import the amplitude data array & convert from Quartet Volts to nanometres by multiplying by 10:
            self.b_scan_amplitudes_raw_nm = load_nmo_periodic_amps_from_mat_file(file_path) * 10

            # Generate the time vector using the scope time limits provided:
            self.n_samples, self.n_a_scans = np.shape(self.b_scan_amplitudes_raw_nm)
            self.t_vector_us = generate_time_vector_us(self.t_min_us_scope, self.t_max_us_scope, self.n_samples)
            # Generate x vector:
            self.x_max_mm = (self.n_a_scans - 1) * self.pitch_mm
            self.x_vector_mm = np.linspace(0, self.x_max_mm, self.n_a_scans)
            # Set x boundaries to contain all data:
            self.boundary_i_max = self.n_a_scans

            # Update everything to reflect the new NMO B-scan data set:
            # No modifiers applied yet:
            self.b_scan_amps_modified_nm = self.b_scan_amplitudes_raw_nm
            # Display the NMO B-scan:
            self.nmo_b_scan_widget.new_amplitude_array(self.b_scan_amps_modified_nm)
            # Set c lims for NMO B-scan plot:
            vmin_default_nm = -0.1
            vmax_default_nm = 0.1
            self.nmo_b_scan_widget.axes_image.set_clim(vmin=vmin_default_nm, vmax=vmax_default_nm)
            self.doubleSpinBox_nmo_c_min.blockSignals(True)
            self.doubleSpinBox_nmo_c_min.setValue(vmin_default_nm)
            self.doubleSpinBox_nmo_c_min.blockSignals(False)
            self.doubleSpinBox_nmo_c_max.blockSignals(True)
            self.doubleSpinBox_nmo_c_max.setValue(vmax_default_nm)
            self.doubleSpinBox_nmo_c_max.blockSignals(False)
            # Set extent:
            self.nmo_b_scan_widget.axes_image.set_extent((0,
                                                          self.x_max_mm,
                                                          self.t_max_us_scope,
                                                          self.t_min_us_scope))
            # Set axis limits:
            self.nmo_b_scan_widget.mpl_canvas.ax.set_xlim(0, self.x_max_mm)
            self.nmo_b_scan_widget.mpl_canvas.ax.set_ylim(self.t_max_us_scope, self.t_min_us_scope)
            self.nmo_b_scan_widget.mpl_canvas.draw()

            # Set x data for interactive lines:
            self.nmo_b_scan_widget.hyperbola_hover.set_xdata(self.x_vector_mm)
            self.nmo_b_scan_widget.hyperbola_click.set_xdata(self.x_vector_mm)

            # Update plot variable input widgets based on dataset limits:
            # NMO plot variables:
            self.doubleSpinBox_nmo_t_min.blockSignals(True)
            self.doubleSpinBox_nmo_t_min.setValue(self.t_min_us_scope)
            self.doubleSpinBox_nmo_t_min.blockSignals(False)
            self.doubleSpinBox_nmo_t_max.blockSignals(True)
            self.doubleSpinBox_nmo_t_max.setValue(self.t_max_us_scope)
            self.doubleSpinBox_nmo_t_max.blockSignals(False)
            self.doubleSpinBox_nmo_t_min.setMinimum(self.t_min_us_scope)
            self.doubleSpinBox_nmo_t_max.setMaximum(self.t_max_us_scope)
            # TK spectrum variables:
            self.doubleSpinBox_tk_t_0_max.blockSignals(True)
            self.doubleSpinBox_tk_t_0_max.setValue(self.t_max_us_scope / 2)
            self.doubleSpinBox_tk_t_0_max.blockSignals(False)
            self.doubleSpinBox_tk_t_0_min.setMinimum(self.t_min_us_scope)
            self.doubleSpinBox_tk_t_0_max.setMaximum(self.t_max_us_scope)

            # Generate v and t_0 vectors:
            self.generate_v_vector_from_limits()
            self.generate_t_0_vector_from_limits()
            # Set v data for the iso-b line & text:
            self.tk_spectrum_widget.new_v_vector_mpers(self.v_vector_mpers)

            # Compute a default TK spectrum using the imported data:
            tk_spectrum_amps = self.compute_tk_from_vectors()

            # Display T-K spectrum:
            # Set data:
            self.tk_spectrum_widget.axes_image.set_data(tk_spectrum_amps)
            # Set Clims for T-K spectrum:
            self.set_tk_clims_from_box_values()
            # Set TK spectrum image extent:
            self.set_tk_extent_from_box_values()

            # Set v data for the iso-b line & text:
            self.tk_spectrum_widget.line_iso_b.set_xdata(self.v_vector_mpers)

            # Draw T-K plot canvas:
            self.tk_spectrum_widget.mpl_canvas.draw()

            # Enable interactive widgets associated with the b-scan plot and Taner-Koehler spectrum:
            self.activate_plot_input_widgets()

            # Enable add modifier button:
            self.pushButton_add_modifier.setEnabled(True)

            # Display the data set name in the label at the top of the screen:
            if name:
                self.label_data_set_name.setText(name)

            # Update the PCV plot widget, if open:
            if self.pcv_viewer_widget:
                self.pcv_viewer_widget.update_n_a_scans(self.n_a_scans)

    def request_file_import_params(self):
        # Open a dialog to request the file import parameters:
        dialog_file_import_params = DialogImportNMOPeriodicMat(parent=self)
        dialog_file_import_params.exec()
        # When the dialog has either been accepted or rejected:
        # Boolean showing whether the user clicked 'accept' or 'cancel':
        provided = dialog_file_import_params.result()
        # Other parameters:
        name = dialog_file_import_params.name_string
        file_path = dialog_file_import_params.file_path
        t_min_us = dialog_file_import_params.t_min_us
        t_max_us = dialog_file_import_params.t_max_us
        pitch_mm = dialog_file_import_params.pitch_mm

        return provided, name, file_path, t_min_us, t_max_us, pitch_mm

    def generate_t_0_vector_from_limits(self):
        self.t_0_vector_us = np.linspace(start=self.doubleSpinBox_tk_t_0_min.value(),
                                         stop=self.doubleSpinBox_tk_t_0_max.value(),
                                         num=self.spinBox_tk_n_t0s.value())

    def generate_v_vector_from_limits(self):
        self.v_vector_mpers = np.linspace(start=self.doubleSpinBox_tk_v_min.value(),
                                          stop=self.doubleSpinBox_tk_v_max.value(),
                                          num=self.spinBox_tk_n_vs.value())

    def set_tk_clims_from_box_values(self):
        self.tk_spectrum_widget.axes_image.set_clim(vmin=self.doubleSpinBox_tk_c_min.value(),
                                                    vmax=self.doubleSpinBox_tk_c_max.value())

    def set_tk_extent_from_box_values(self):
        self.tk_spectrum_widget.axes_image.set_extent((self.doubleSpinBox_tk_v_min.value(),
                                                       self.doubleSpinBox_tk_v_max.value(),
                                                       self.doubleSpinBox_tk_t_0_max.value(),
                                                       self.doubleSpinBox_tk_t_0_min.value()))

    def new_tk_spectrum_amps_array(self, tk_amps_array):
        # Display the new array of TK spectrum amplitudes:
        # Set data:
        self.tk_spectrum_widget.axes_image.set_data(tk_amps_array)
        # Set extent:
        self.set_tk_extent_from_box_values()
        # Set v data for the iso-b line & text:
        self.tk_spectrum_widget.line_iso_b.set_xdata(self.v_vector_mpers)
        # Clear t_0 data for iso-b line:
        self.tk_spectrum_widget.line_iso_b.set_ydata([])
        # Make TK hover annotations invisible:
        self.tk_spectrum_widget.set_hover_annotations_visible(False)
        # Make mouse hover hyperbola invisible:
        self.nmo_b_scan_widget.hyperbola_hover.set_visible(False)

    def compute_tk_from_vectors(self):
        # Extract the contributions to the TK spectrum from each A-scan by interpolating the B-scan:
        self.extract_tk_contributions()
        # Apply any masks requested by tools:
        self.mask_tk_contributions()
        # Sum the contributions over the range of A-scans requested by tools:
        tk_spectrum_amps = self.sum_tk_contributions()
        return tk_spectrum_amps

    def extract_tk_contributions(self):
        self.spectrum_contributions_3d, self.query_times_by_a_scan_3d = extract_tk_contributions(
            self.b_scan_amps_modified_nm, self.t_vector_us, self.x_vector_mm, self.v_vector_mpers, self.t_0_vector_us)

    def mask_tk_contributions(self):
        if self.groupBox_box_mask.isChecked():
            # The user has requested to exclude a particular region of the B-scan from contributing to the TK spectrum.
            # Create masks based on the values of the query times for the excluded A-scans:
            # Copy masks from query times array to spectrum contributions array:
            pass
        else:
            # No masking requested.
            pass

    def sum_tk_contributions(self):
        # Sum contributions according to x_min and x_max boundaries:
        tk_spectrum_amps = np.sum(self.spectrum_contributions_3d[self.boundary_i_min : self.boundary_i_max], axis=0)
        return tk_spectrum_amps

    def nmo_c_min_changed(self, c_min_mv):
        self.nmo_b_scan_widget.axes_image.set_clim(vmin=c_min_mv)
        self.nmo_b_scan_widget.mpl_canvas.draw()

    def nmo_c_max_changed(self, c_max_mv):
        self.nmo_b_scan_widget.axes_image.set_clim(vmax=c_max_mv)
        self.nmo_b_scan_widget.mpl_canvas.draw()

    def tk_c_min_changed(self, c_min):
        self.tk_spectrum_widget.axes_image.set_clim(vmin=c_min)
        self.tk_spectrum_widget.mpl_canvas.draw()

    def tk_c_max_changed(self, c_max):
        self.tk_spectrum_widget.axes_image.set_clim(vmax=c_max)
        self.tk_spectrum_widget.mpl_canvas.draw()

    def nmo_t_min_changed(self, t_min_us):
        self.nmo_b_scan_widget.mpl_canvas.ax.set_ylim(top=t_min_us)
        self.nmo_b_scan_widget.mpl_canvas.draw()

    def nmo_t_max_changed(self, t_max_us):
        self.nmo_b_scan_widget.mpl_canvas.ax.set_ylim(bottom=t_max_us)
        self.nmo_b_scan_widget.mpl_canvas.draw()

    def update_nmo_b_scan_hyp_hover(self, v_hover_mpers, t_0_hover_us):
        # Draw hyperbola for [v,b] point:
        # Compute t values for this hyperbola:
        t_hyp_us = compute_t_hyp_us(self.x_vector_mm, v_hover_mpers, t_0_hover_us)
        # Set ydata for hyp line:
        self.nmo_b_scan_widget.hyperbola_hover.set_ydata(t_hyp_us)

    def tk_hover(self, event):
        if self.b_scan_amplitudes_raw_nm is None:
            # No dataset loaded.  Take no action.
            return
        elif not event.inaxes:
            # Mouse is in TK figure but not in data axes.
            # Check if hyperbola is visible:
            hyp_hover_visible = self.nmo_b_scan_widget.hyperbola_hover.get_visible()
            if hyp_hover_visible:
                # Make invisible:
                self.nmo_b_scan_widget.hyperbola_hover.set_visible(False)
                self.tk_spectrum_widget.set_hover_annotations_visible(False)

                # Blit to remove:
                self.nmo_b_scan_widget.blit_manager.blit_all_animated_artists()
                self.tk_spectrum_widget.blit_manager.blit_all_animated_artists()
            else:
                # Hyperbola is already invisible.  No need to blit.
                pass
        else:
            # Mouse is in TK data axes.
            v_hover_mpers = event.xdata
            t_0_hover_us = event.ydata
            # Compute t values for this hyperbola:
            t_hyp_us = compute_t_hyp_us(self.x_vector_mm, v_hover_mpers, t_0_hover_us)
            # Draw hyperbola on NMO B-scan for hovered [v,b] point:
            self.nmo_b_scan_widget.update_hyp_hover(t_hyp_us)

            # Update hover annotations on TK plot:
            self.tk_spectrum_widget.update_hover_annotations(v_hover_mpers, t_0_hover_us)

            # Check if hyp hover is visible:
            if not self.nmo_b_scan_widget.hyperbola_hover.get_visible():
                # Hyp hover is invisible.
                # Make all hover annotations visible on both TK and NMO widgets:
                self.nmo_b_scan_widget.hyperbola_hover.set_visible(True)
                self.tk_spectrum_widget.set_hover_annotations_visible(True)

            # Blit changes:
            self.nmo_b_scan_widget.blit_manager.blit_all_animated_artists()
            self.tk_spectrum_widget.blit_manager.blit_all_animated_artists()

    def activate_plot_input_widgets(self):
        # NMO B-scan plot widgets:
        # Plot tab:
        self.doubleSpinBox_nmo_c_min.setEnabled(True)
        self.doubleSpinBox_nmo_c_max.setEnabled(True)
        self.doubleSpinBox_nmo_t_min.setEnabled(True)
        self.doubleSpinBox_nmo_t_max.setEnabled(True)
        # Data tab:
        self.doubleSpinBox_source_half_width_mm.setEnabled(True)
        self.doubleSpinBox_rise_time_us.setEnabled(True)
        # Tools tab:
        self.checkBox_x_max.setEnabled(True)
        self.groupBox_box_mask.setEnabled(True)
        self.doubleSpinBox_box_mask_t_lower.setEnabled(True)
        self.doubleSpinBox_box_mask_t_upper.setEnabled(True)
        self.spinBox_box_mask_i_lower.setEnabled(True)
        self.spinBox_box_mask_i_upper.setEnabled(True)
        # T-K spectrum plot widgets:
        # Plot tab:
        self.doubleSpinBox_tk_c_min.setEnabled(True)
        self.doubleSpinBox_tk_c_max.setEnabled(True)
        # Data tab:
        self.doubleSpinBox_tk_v_min.setEnabled(True)
        self.doubleSpinBox_tk_v_max.setEnabled(True)
        self.doubleSpinBox_tk_t_0_min.setEnabled(True)
        self.doubleSpinBox_tk_t_0_max.setEnabled(True)
        self.spinBox_tk_n_vs.setEnabled(True)
        self.spinBox_tk_n_t0s.setEnabled(True)

    def v_vector_changed(self):
        # Compute new v vector:
        self.generate_v_vector_from_limits()
        # Set v data for the iso-b line & text:
        self.tk_spectrum_widget.new_v_vector_mpers(self.v_vector_mpers)
        # Compute new T-K spectrum amplitudes:
        tk_spectrum_amps = self.compute_tk_from_vectors()
        # Display new spectrum array:
        self.new_tk_spectrum_amps_array(tk_spectrum_amps)
        # Draw T-K plot canvas:
        self.tk_spectrum_widget.mpl_canvas.draw()
        # Blit NMO canvas (to remove hyperbola):
        self.nmo_b_scan_widget.blit_manager.blit_all_animated_artists()

    def t_0_vector_changed(self):
        # Compute new t_0 vector:
        self.generate_t_0_vector_from_limits()
        # Compute new T-K spectrum amplitudes:
        tk_spectrum_amps = self.compute_tk_from_vectors()
        # Display new spectrum array:
        self.new_tk_spectrum_amps_array(tk_spectrum_amps)
        # Draw T-K plot canvas:
        self.tk_spectrum_widget.mpl_canvas.draw()
        # Blit NMO canvas (to remove hyperbola):
        self.nmo_b_scan_widget.blit_manager.blit_all_animated_artists()

    def rise_time_changed(self):
        rise_time_us = self.doubleSpinBox_rise_time_us.value()
        # Compute new time min and max:
        t_min_rise_time_us = self.t_min_us_scope - rise_time_us
        t_max_rise_time_us = self.t_max_us_scope - rise_time_us
        # Re-compute time vector:
        self.t_vector_us = generate_time_vector_us(t_min_rise_time_us, t_max_rise_time_us, self.n_samples)

        # Update plot variable input widgets based on dataset limits:
        # NMO plot variables:
        self.doubleSpinBox_nmo_t_min.blockSignals(True)
        self.doubleSpinBox_nmo_t_min.setValue(t_min_rise_time_us)
        self.doubleSpinBox_nmo_t_min.blockSignals(False)
        self.doubleSpinBox_nmo_t_max.blockSignals(True)
        self.doubleSpinBox_nmo_t_max.setValue(t_max_rise_time_us)
        self.doubleSpinBox_nmo_t_max.blockSignals(False)
        self.doubleSpinBox_nmo_t_min.setMinimum(t_min_rise_time_us)
        self.doubleSpinBox_nmo_t_max.setMaximum(t_max_rise_time_us)
        # TK spectrum variables:
        self.doubleSpinBox_tk_t_0_min.setMinimum(t_min_rise_time_us)
        self.doubleSpinBox_tk_t_0_max.setMaximum(t_max_rise_time_us)

        # Update the NMO B-scan extent:
        self.nmo_b_scan_widget.axes_image.set_extent((0, self.x_max_mm, t_max_rise_time_us, t_min_rise_time_us))

        # Update the T-K spectrum data:
        tk_spectrum_amps = self.compute_tk_from_vectors()
        self.new_tk_spectrum_amps_array(tk_spectrum_amps)

        # Draw both axes:
        self.tk_spectrum_widget.mpl_canvas.draw()
        self.nmo_b_scan_widget.mpl_canvas.draw()

    def checkbox_x_max_toggled(self):
        if self.checkBox_x_max.isChecked():
            # The user has checked the checkbox, requesting an x max boundary line:
            self.boundary_line_x_max = BoundaryLine(self.nmo_b_scan_widget.mpl_canvas,
                                                    'x', 'max',
                                                    self.nmo_b_scan_widget.blit_manager,
                                                    self.nmo_b_scan_widget.cursor_manager)
            # Wire the boundary_moved signal to the boundary_x_max changed method:
            self.boundary_line_x_max.boundary_moved.connect(self.boundary_x_max_changed)
        else:
            # The user is requesting to remove the existing x_max boundary line:
            self.boundary_line_x_max.safe_disconnect()
            self.boundary_line_x_max = None
            # Re-set the TK spectrum using the whole B-scan:
            self.boundary_x_max_changed(self.x_max_mm)
            
        # Blit appearance or disappearance:
        self.nmo_b_scan_widget.blit_manager.blit_all_animated_artists()

    def boundary_x_max_changed(self, boundary_x_max_mm):
        self.boundary_i_max = round(boundary_x_max_mm / self.pitch_mm)
        # Sum TK contributions within new boundaries:
        tk_spectrum_amps = self.sum_tk_contributions()
        # Set data for new TK spectrum:
        self.tk_spectrum_widget.axes_image.set_data(tk_spectrum_amps)
        # Re-draw the TK spectrum plot:
        self.tk_spectrum_widget.mpl_canvas.draw()

    def tk_rect_on_select(self, eclick, erelease):
        # Use the rectangle corner coordinates to specify the axis ranges of the TKzoom widget:
        v_click, t_0_click = eclick.xdata, eclick.ydata
        v_release, t_0_release = erelease.xdata, erelease.ydata

        # Find the min and max values of v and t_0:
        v_min_mpers, v_max_mpers = tuple(sorted([v_click, v_release]))
        t_0_min_mpers, t_0_max_mpers = tuple(sorted([t_0_click, t_0_release]))

        # Is there a TKZoom widget open?
        if not self.tk_zoom_widget:
            # Instantiate a new TK zoom widget:
            self.tk_zoom_widget = TKZoomWidget(self.b_scan_amps_modified_nm, self.x_vector_mm, self.t_vector_us)
            self.tk_zoom_widget.tk_zoom_closed.connect(self.tk_zoom_widget_closed_slot)
            self.tk_zoom_widget.tk_zoom_hyperbola_found.connect(self.tk_zoom_hyp_found)
            self.tk_zoom_widget.show()

        # Send data to the tk zoom widget:
        self.tk_zoom_widget.new_limits_from_rectangle(v_min_mpers, v_max_mpers, t_0_min_mpers, t_0_max_mpers,
                                                      self.boundary_i_min, self.boundary_i_max)

        # Remove the RectangleSelector:
        self.rect_selector_tk.disconnect_events()
        self.rect_selector_tk = None

        # Un-check the tool button:
        self.pushButton_box_select.setChecked(False)

    def tk_box_select_button_clicked(self, checked):
        if checked:
            # Instantiate a RectangleSelector on the TK canvas:
            self.rect_selector_tk = RectangleSelector(self.tk_spectrum_widget.mpl_canvas.ax,
                                                      onselect=self.tk_rect_on_select,
                                                      interactive=False,
                                                      useblit=True,
                                                      button=[1, 3],  # disable middle button
                                                      minspanx=5, minspany=5,
                                                      spancoords='pixels')

    def tk_zoom_widget_closed_slot(self):
        # Set Python reference for tk_zoom widget to none:
        self.tk_zoom_widget = None

    def tk_zoom_hyp_found(self, v_t_0_tuple):
        v_mpers, t_0_mpers = v_t_0_tuple
        # Plot the hyperbola on the B-scan plot:
        self.update_nmo_b_scan_hyp_hover(v_mpers, t_0_mpers)
        # Update the TK plot hover annotations:
        self.tk_spectrum_widget.update_hover_annotations(v_mpers, t_0_mpers)
        # Blit changes:
        self.nmo_b_scan_widget.blit_manager.blit_all_animated_artists()
        self.tk_spectrum_widget.blit_manager.blit_all_animated_artists()

    def print_tk_clicked(self):
        # Instantiate the PrettyPrint class:
        title_string = f'T-K plot: {self.label_data_set_name.text()}'
        dialog_pretty_print = DialogPrettyPrint(self, self.tk_spectrum_widget.mpl_canvas.fig,
                                                r'Wave speed $c$ ($\mathregular{ms^{-1}}$)',
                                                y_label_string='$t_{0}$ (Î¼s)',
                                                colorbar_string='Sum (mV)',
                                                title_string=title_string)
        dialog_pretty_print.exec()

    def toggle_pcv_viewer(self):
        if self.pcv_viewer_widget:
            # The widget already exists.  Close it:
            self.pcv_viewer_widget.close()
            # Set Python reference to None:
            self.pcv_viewer_widget = None
        else:
            # The widget is not already open.
            # If a pixel in the TK spectrum is selected, extract the PCV:
            if self.tuple_v_t_0_clicked:
                pcv_nm = self.extract_pcv(self.tuple_v_t_0_clicked)
            else:
                pcv_nm = None
            # Create a new PCVViewer instance:
            self.pcv_viewer_widget = PCVViewer(self.n_a_scans, self.doubleSpinBox_nmo_c_min.value(),
                                               self.doubleSpinBox_nmo_c_max.value(), pcv_nm)
            # Wire signals to slots:
            self.pcv_viewer_widget.pcv_viewer_closed.connect(self.slot_pcv_viewer_closed)
            # Open the window:
            self.pcv_viewer_widget.show()

    def slot_pcv_viewer_closed(self):
        self.action_toggle_pcv_viewer.setChecked(False)
        # Set Python reference to None:
        self.pcv_viewer_widget = None

    def tk_pixel_clicked(self, tuple_v_t_0):
        # Store clicked (v_mpers, t_0_us) tuple:
        self.tuple_v_t_0_clicked = tuple_v_t_0

        if tuple_v_t_0:
            # Tuple is not None.
            # Update clicked hyperbola on NMO B-scan plot:
            t_hyp_clicked_us = compute_t_hyp_us(self.x_vector_mm, tuple_v_t_0[0], tuple_v_t_0[1])
            self.nmo_b_scan_widget.update_hyp_click(t_hyp_clicked_us)

            if self.pcv_viewer_widget:
                # Extract associated PCV:
                pcv_nm = self.extract_pcv(self.tuple_v_t_0_clicked)
                self.pcv_viewer_widget.update_pcv_values(pcv_nm)
        else:
            # Tuple is None:
            # Prompt NMO B-scan view widget to make click hyperbola invisible:
            self.nmo_b_scan_widget.hyperbola_click.set_visible(False)
        # Blit changes:
        self.nmo_b_scan_widget.blit_manager.blit_all_animated_artists()

    def extract_pcv(self, tuple_c_t_0):
        # Sample the B-scan via interpolation at the t_hyp times for each A-scan:
        c_mpers = tuple_c_t_0[0]
        t_0_us = tuple_c_t_0[1]
        spectrum_contributions_3d, _ = extract_tk_contributions(self.b_scan_amps_modified_nm, self.t_vector_us,
                                                                self.x_vector_mm, [c_mpers], [t_0_us])
        pcv_nm = np.squeeze(spectrum_contributions_3d)
        return pcv_nm
